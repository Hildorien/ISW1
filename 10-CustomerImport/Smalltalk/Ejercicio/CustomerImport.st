Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'MatasCadaval 11/21/2017 20:38'!assertHasIdInstanceVariable: aClass 		"(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]"	(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'MatasCadaval 11/21/2017 20:39'!assertIsValidFor: aClass 	"(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ]"		(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ]  ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImportTest methodsFor: 'importing' stamp: 'MatasCadaval 11/20/2017 20:10'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream on: system)		import! !!CustomerImportTest methodsFor: 'importing' stamp: 'MatasCadaval 11/21/2017 19:30'!importSuppliersFrom: inputStream 	(SupplierImporter from: inputStream on: system)		import! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/20/2017 20:10'!alwaysImportedCustomer	^ system		customerIdentifiedAs: self alwaysImportedCustomerIdType		numbered: self alwaysImportedCustomerIdNumber		ifNone: [ self fail ]! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/21/2017 21:14'!validCustomerTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 09:48'!existingCustomerRecordWithMoreThanThreeFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord , 'EC,D,5456774,Pepe'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 14:36'!newCustomerWithoutSupplierTestData	^ ReadStream on: 'NC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 14:42'!existingCustomerWithoutSupplierTestData	^ ReadStream on: 'EC,D,5456774'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 09:35'!existingCustomerRecordWithLessThanThreeFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord , 'EC,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 02:33'!newCustomerRecordStartingWithMoreThanOneNCTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NCC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 02:41'!existingCustomerRecordStartingWithMoreThanOneECTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'ECC,D,5456774'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 09:08'!newCustomerRecordWithLessThanFiveFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'MatasCadaval 11/23/2017 09:29'!newCustomerRecordWithMoreThanFiveFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord ,'NC,Pepe,Sanchez,D,22333444,x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 02:20'!addressRecordStartingWithMoreThanOneATestDataForCustomerImporter		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 02:23'!addressRecordStartingWithMoreThanOneATestDataForSupplierImporter	^ ReadStream on: self alwaysImportedSupplierRecord, 'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 02:21'!addressRecordWithMoreThanSixFieldsTestDataForCustomerImporter		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 02:52'!addressRecordWithLessThanSixFieldsTestDataForSupplierImporter	^ ReadStream on: self alwaysImportedSupplierRecord ,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 08:38'!addressRecordWithMoreThanSixFieldsTestDataForSupplierImporter	^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 08:41'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 02:21'!addressRecordWithLessThanSixFieldsTestDataForCustomerImporter		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'MatasCadaval 11/23/2017 08:42'!addressWithoutSupplierTestData	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/20/2017 20:10'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/23/2017 02:20'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importCustomersFrom: self addressRecordStartingWithMoreThanOneATestDataForCustomerImporter ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'HernanWilkinson 11/2/2016 15:52'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importCustomersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/23/2017 02:21'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importCustomersFrom: self addressRecordWithLessThanSixFieldsTestDataForCustomerImporter ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/20/2017 20:10'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/21/2017 21:14'!testImportCustomers	self importCustomersFrom: self validCustomerTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/23/2017 02:21'!testCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestDataForCustomerImporter ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/20/2017 20:10'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - customer importer' stamp: 'MatasCadaval 11/23/2017 08:41'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter addressWithoutCustomerErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/23/2017 15:22'!assert: aSupplier hasCustomerNamed: aFirstName lastName: aLastName identifiedAs: anIdentificationType withNumber: anIdentificationNumber 	| customer |		customer := aSupplier customersIdentifiedAs: anIdentificationType withNumber: anIdentificationNumber ifNone: [ self fail ].	self assert: customer firstName equals: aFirstName.	self assert: customer lastName equals: aLastName.	self assert: customer identificationType equals: anIdentificationType.	self assert: customer identificationNumber equals: anIdentificationNumber.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/20/2017 20:10'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system		customerIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/20/2017 20:10'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := system		customerIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: customer		isNamed: 'Pepe'		lastName: 'Sanchez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 2.	self		assert: customer		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: customer		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/20/2017 20:10'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomersSize equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/23/2017 14:54'!assertImportedSuppliersSizeIsCorrect	self assert: system allSuppliersSize equals: 1! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/23/2017 15:11'!assert: aSupplier isNamed: aName identfiedAs: anIdentificationType withNumber: anIdentificationNumber andNumberOfCustomers: aNumberOfCustomers andNumberOfAddresses: aNumberOfAddresses	self assert: aSupplier name equals: aName.	self assert: aSupplier identificationType equals: anIdentificationType.	self assert: aSupplier identificationNumber equals: anIdentificationNumber.	self assert: aSupplier numberOfCustomers equals: aNumberOfCustomers. 	self assert: aSupplier numberOfAddresses equals: aNumberOfAddresses. 	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MatasCadaval 11/23/2017 17:42'!assertSupplier1WasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := system		supplierIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		andNumberOfCustomers: 2		andNumberOfAddresses: 2.	self		assert: supplier		hasCustomerNamed: 'Pepe'		lastName: 'Sanchez'		identifiedAs: 'D'		withNumber: '22333444'.	self		assert: supplier		hasCustomerNamed: 'Juan'		lastName: 'Garcia'		identifiedAs: 'D'		withNumber: '5456774'.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test12CanNotImportNewCustomerRecordWithLessThanFiveFields	self		should: [ self				importSuppliersFrom: self newCustomerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:53'!test07CanNotImportNewCustomerAsExistingCustomer	self		should: [ self				importSuppliersFrom: self supplierRecordWithNewCustomerAsExistingCustomer ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter newCustomerAsExistingCustomerErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test18ImportSuppliers	self addJuanGarciaAsCustomer .	self importSuppliersFrom: self validSupplierTestData.	self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WasImportedCorrectly.! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test13CanNotImportNewCustomerRecordWithMoreThanFiveFields	self		should: [ self				importSuppliersFrom: self newCustomerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:53'!test08CanNotImportExistingCustomerAsNewCustomer		self addJuanGarciaAsCustomer .		self		should: [ self				importSuppliersFrom: self supplierRecordWithJuanGarciaAsNewCustomer ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter existingCustomerAsNewCustomerErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:51'!test01CanNotImportSupplierRecordWithLessThanFourFields		self		should: [ self importSuppliersFrom: self supplierRecordWithLessThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidSupplierRecordErrorDescription.			self assert: system isSuppliersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:53'!test11CanNotImportAddressWithoutSupplier	self		should: [ self importSuppliersFrom: self addressWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter addressWithoutSupplierErrorDescription.			self assert: system isSuppliersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:53'!test10SupplierImporterCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importSuppliersFrom: self addressRecordWithMoreThanSixFieldsTestDataForSupplierImporter ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:52'!test05SupplierImporterShouldNotImportExistingCustomerRecordsStartingWithMoreThanEC	self		should: [ self				importSuppliersFrom: self existingCustomerRecordStartingWithMoreThanOneECTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedSupplier isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:51'!test02CanNotImportSupplierRecordWithMoreThanFourFields		self		should: [ self importSuppliersFrom: self supplierRecordWithMoreThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidSupplierRecordErrorDescription.			self assert: system isSuppliersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:51'!test03ShouldNotImportSupplierRecordsStartingWithMoreThanS	self		should: [ self				importSuppliersFrom: self supplierRecordStartingWithMoreThanOneSTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: system isSuppliersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test17CanNotImportExistingCustomerWithoutSupplier	self		should: [ self importSuppliersFrom: self existingCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerWithoutSupplierErrorDescription.			self assert: system isSuppliersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:53'!test09SupplierImporterCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importSuppliersFrom: self addressRecordWithLessThanSixFieldsTestDataForSupplierImporter ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:52'!test06SupplierImporterShouldNotImportNewCustomerRecordsStartingWithMoreThanNC	self		should: [ self				importSuppliersFrom: self newCustomerRecordStartingWithMoreThanOneNCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test16CanNotImportNewCustomerWithoutSupplier	self		should: [ self importSuppliersFrom: self newCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerWithoutSupplierErrorDescription.			self assert: system isSuppliersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test14CanNotImportExistingCustomerRecordWithLessThanThreeFields	self		should: [ self				importSuppliersFrom: self existingCustomerRecordWithLessThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:51'!test04SupplierImporterShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importSuppliersFrom: self addressRecordStartingWithMoreThanOneATestDataForSupplierImporter ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing - supplier importer' stamp: 'MatasCadaval 11/23/2017 17:54'!test15CanNotImportExistingCustomerRecordWithMoreThanThreeFields	self		should: [ self				importSuppliersFrom: self existingCustomerRecordWithMoreThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'adding' stamp: 'MatasCadaval 11/23/2017 14:52'!addJuanGarciaAsCustomer		| inputStream |	inputStream := ReadStream on: 'C,Juan,Garcia,D,5456774' .		self importCustomersFrom: inputStream ! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/21/2017 19:28'!supplierRecordWithLessThanFourFieldsTestData	^ ReadStream on: 'S,Pepe,D'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 17:43'!validSupplierTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 00:25'!alwaysImportedSupplierIdNumber	^'123'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 00:09'!alwaysImportedSupplierRecord	^ 'S,Supplier1,D,123'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 00:24'!alwaysImportedSupplier	^ system		supplierIdentifiedAs: self alwaysImportedSupplierIdType		numbered: self alwaysImportedSupplierIdNumber		ifNone: [ self fail ]! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/21/2017 21:00'!supplierRecordWithMoreThanFourFieldsTestData	^ ReadStream on: 'S,Pepe,Gomez,D,33121'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 00:25'!alwaysImportedSupplierIdType	^'D'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 14:52'!supplierRecordWithJuanGarciaAsNewCustomer		^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Juan,Garcia,D,5456774'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/21/2017 21:04'!supplierRecordStartingWithMoreThanOneSTestData	^ ReadStream on:'SS,Pepe,D,22333444'! !!CustomerImportTest methodsFor: 'test data - supplier' stamp: 'MatasCadaval 11/23/2017 00:08'!supplierRecordWithNewCustomerAsExistingCustomer		^ ReadStream on: self alwaysImportedSupplierRecord,'EC,D,5456774'! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/23/2017 18:20'!setUp	system := Environment current createErpSystem.	system start.	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/21/2017 00:34'!tearDown	system commit.	system stop! !Object subclass: #CustomerImporter	instanceVariableNames: 'line readStream record newCustomer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/16/2017 20:12'!importCustomer	self assertValidCustomerRecordSize.	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	system addCustomer: newCustomer! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].	! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:55'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 17:54'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 16:01'!signalAddressWithoutCustomerError	self error: self class addressWithoutCustomerErrorDescription.! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 18:01'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/2/2016 10:52'!signalInvalidCustomerRecord 		self error: self class invalidCustomerRecordErrorDescription ! !!CustomerImporter methodsFor: 'initialization' stamp: 'MatasCadaval 11/16/2017 20:03'!initializeOn: aReadStream on: aCustomerSystem	readStream := aReadStream. 	system := aCustomerSystem .! !!CustomerImporter methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/1/2016 17:52'!importRecord		self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].		self signalInvalidRecordType! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:54'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 10:55'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:55'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/23/2017 08:44'!importAddress	| newAddress |	self assertThereIsCustomerForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newCustomer addAddress: newAddress! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:55'!isAddressRecord	^ record first = 'A'! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/23/2017 08:44'!assertThereIsCustomerForAddress	newCustomer isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 18:00'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!CustomerImporter class methodsFor: 'instance creation' stamp: 'MatasCadaval 11/16/2017 20:02'!from: aReadStream on: aCustomerSystem	^self new initializeOn: aReadStream on: aCustomerSystem! !Object subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/16/2017 20:18'!allCustomersSize
	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/16/2017 20:18'!addCustomer: tempNewCustomer
	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/16/2017 20:18'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock
	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/16/2017 20:18'!isCustomersEmpty
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:18'!commit
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:18'!start
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:18'!beginTransaction
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/21/2017 00:34'!stop
	self subclassResponsibility! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'accessing' stamp: 'MatasCadaval 11/20/2017 20:54'!current	^ self allSubclasses 		detect: [ :anEnvironmentSubclass | anEnvironmentSubclass isCurrent ]		ifFound: [ :anEnvironmentSubClass | anEnvironmentSubClass ]		ifNone: [ self error: 'No environment found' ]! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'asserting' stamp: 'MatasCadaval 11/20/2017 20:56'!isCurrent	^ IntegrationEnvironment isCurrent not! !!DevelopmentEnvironment class methodsFor: 'system' stamp: 'MatasCadaval 11/23/2017 18:39'!createErpSystem	^ TransientErpSystem new! !Object subclass: #ErpSystem	instanceVariableNames: 'supplierSystem customerSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:26'!isSuppliersEmpty	^ supplierSystem isSuppliersEmpty ! !!ErpSystem methodsFor: 'testing' stamp: 'MatasCadaval 11/23/2017 18:26'!isCustomersEmpty	^ customerSystem isCustomersEmpty ! !!ErpSystem methodsFor: 'accessing' stamp: 'MatasCadaval 11/23/2017 18:26'!stop	customerSystem stop .	supplierSystem stop .! !!ErpSystem methodsFor: 'accessing' stamp: 'MatasCadaval 11/23/2017 18:26'!start		customerSystem start .	supplierSystem start .	! !!ErpSystem methodsFor: 'accessing' stamp: 'MatasCadaval 11/23/2017 18:25'!commit	customerSystem commit .	supplierSystem commit .! !!ErpSystem methodsFor: 'initialization' stamp: 'MatasCadaval 11/23/2017 18:23'!initialize
	self subclassResponsibility! !!ErpSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/23/2017 18:25'!addCustomer: aCustomer 	customerSystem addCustomer: aCustomer ! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'MatasCadaval 11/23/2017 18:25'!addSupplier: aSupplier 	supplierSystem addSupplier: aSupplier ! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'MatasCadaval 11/23/2017 18:25'!allSuppliersSize	^ supplierSystem allSuppliersSize ! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'MatasCadaval 11/23/2017 18:25'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneBlock 		^ customerSystem customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneBlock ! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'MatasCadaval 11/23/2017 18:26'!supplierIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneClosure 	^ supplierSystem supplierIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneClosure ! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'MatasCadaval 11/23/2017 18:25'!allCustomersSize	^ customerSystem allCustomersSize ! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/23/2017 18:25'!beginTransaction		customerSystem beginTransaction .	supplierSystem beginTransaction  ! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'asserting' stamp: 'MatasCadaval 11/23/2017 18:57'!isCurrent		^ false! !!IntegrationEnvironment class methodsFor: 'system' stamp: 'MatasCadaval 11/23/2017 18:20'!createErpSystem	^ PersistentErpSystem new ! !Object subclass: #Party	instanceVariableNames: 'id identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Party methodsFor: 'addresses' stamp: 'MatasCadaval 11/23/2017 18:07'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'MatasCadaval 11/23/2017 18:06'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'MatasCadaval 11/23/2017 18:08'!numberOfAddresses		^addresses size! !!Party methodsFor: 'addresses' stamp: 'MatasCadaval 11/23/2017 18:07'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'MatasCadaval 11/23/2017 18:08'!addressesIsEmpty		^addresses isEmpty! !!Party methodsFor: 'identification' stamp: 'MatasCadaval 11/23/2017 18:08'!identificationNumber		^identificationNumber ! !!Party methodsFor: 'identification' stamp: 'MatasCadaval 11/23/2017 18:08'!identificationType		^identificationType ! !!Party methodsFor: 'identification' stamp: 'MatasCadaval 11/23/2017 18:08'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Party methodsFor: 'identification' stamp: 'MatasCadaval 11/23/2017 18:08'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Party methodsFor: 'identification' stamp: 'MatasCadaval 11/23/2017 18:08'!isIdentifiedAs: anIdentificationType numbered: anIdentificationNumber		^ (identificationType = anIdentificationType) and: [identificationNumber = anIdentificationNumber]! !!Party methodsFor: 'initialization' stamp: 'MatasCadaval 11/23/2017 18:05'!initialize
	addresses := OrderedCollection new! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/16/2017 20:15'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| customers |	customers := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.	^ customers size = 1		ifTrue: [ customers anyOne ]		ifFalse: noneBlock! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/20/2017 20:44'!allCustomersSize	^ (session selectAllOfType: Customer) size! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/21/2017 19:01'!addCustomer: newCustomer	session persist: newCustomer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/20/2017 20:44'!isCustomersEmpty	^ (session selectAllOfType: Customer) isEmpty! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/13/2017 21:20'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:15'!commit	session commit! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:15'!start	session open! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/13/2017 21:21'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:15'!beginTransaction	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/21/2017 00:36'!stop	session close ! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/16/2017 20:15'!initialize	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping)! !ErpSystem subclass: #PersistentErpSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentErpSystem methodsFor: 'initialization' stamp: 'MatasCadaval 11/22/2017 22:40'!initialize	customerSystem := PersistentCustomerSystem new .	supplierSystem := PersistentSupplierSystem new .	! !Party subclass: #Supplier	instanceVariableNames: 'name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Supplier methodsFor: 'customers' stamp: 'MatasCadaval 11/23/2017 15:22'!customersIdentifiedAs: anIdentificationType withNumber: anIdentificationNumber ifNone: noneClosure 	^ customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ] ifNone: noneClosure 	! !!Supplier methodsFor: 'customers' stamp: 'MatasCadaval 11/23/2017 02:10'!numberOfCustomers	^ customers size ! !!Supplier methodsFor: 'customers' stamp: 'MatasCadaval 11/23/2017 00:39'!customersIsEmpty	^customers isEmpty ! !!Supplier methodsFor: 'customers' stamp: 'MatasCadaval 11/22/2017 23:43'!addCustomer: aCustomer 	customers add: aCustomer ! !!Supplier methodsFor: 'customers' stamp: 'MatasCadaval 11/23/2017 02:41'!isCustomersEmpty		^ customers isEmpty ! !!Supplier methodsFor: 'customers' stamp: 'MatasCadaval 11/22/2017 23:26'!customers	^ customers ! !!Supplier methodsFor: 'name' stamp: 'MatasCadaval 11/21/2017 20:48'!name	^ name! !!Supplier methodsFor: 'name' stamp: 'MatasCadaval 11/21/2017 20:49'!name: aName	name := aName! !!Supplier methodsFor: 'initialization' stamp: 'MatasCadaval 11/23/2017 18:11'!initialize		super initialize .	customers := OrderedCollection new.! !Object subclass: #SupplierImporter	instanceVariableNames: 'readStream system line record newCustomer newSupplier'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImporter methodsFor: 'initialization' stamp: 'MatasCadaval 11/21/2017 19:35'!initializeOn: aReadStream on: anErpSystem 	readStream := aReadStream. 	system := anErpSystem .		! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'MatasCadaval 11/21/2017 19:48'!isSupplierRecord	^ record first = 'S'! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'MatasCadaval 11/21/2017 23:06'!importSupplier	self assertValidSupplierRecordSize.	newSupplier := Supplier new.	newSupplier name: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth .	system addSupplier: newSupplier! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'MatasCadaval 11/23/2017 09:10'!assertValidSupplierRecordSize	record size ~= 4 ifTrue: [ self signalInvalidSupplierRecord ].! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/22/2017 23:52'!assertValidExistingCustomerRecordSize	record size ~= 3 ifTrue: [ self signalInvalidCustomerRecord ].! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/23/2017 14:39'!assertThereIsSupplierForCustomer	newSupplier isNil ifTrue: [ self signalCustomerWithoutSupplierError ].! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/22/2017 23:52'!assertValidNewCustomerRecordSize	record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/21/2017 23:00'!isExistingCustomerRecord	^ record first = 'EC'! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/21/2017 21:29'!isNewCustomerRecord	^ record first = 'NC'! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/23/2017 01:48'!assertNewCustomerDoesNotExist	system customerIdentifiedAs: record fourth numbered: record fifth ifNone: [ ^ true ] .	self signalExistingCustomerAsNewCustomer 	 		! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/23/2017 14:38'!importNewCustomer	self assertValidNewCustomerRecordSize.	self assertNewCustomerDoesNotExist .		self assertThereIsSupplierForCustomer .		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	system addCustomer: newCustomer .	newSupplier addCustomer: newCustomer	! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MatasCadaval 11/23/2017 14:44'!importExistingCustomer	self assertValidExistingCustomerRecordSize .	self assertThereIsSupplierForCustomer .	newCustomer := system customerIdentifiedAs: record second numbered: record third ifNone: [ self signalNewCustomerAsExistingCustomer ] .   	newSupplier addCustomer: newCustomer! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MatasCadaval 11/21/2017 23:00'!importRecord	self isSupplierRecord ifTrue: [ ^self importSupplier ] .	self isNewCustomerRecord ifTrue: [ ^self importNewCustomer ].	self isExistingCustomerRecord ifTrue: [ ^self importExistingCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].	self signalInvalidRecordType! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MatasCadaval 11/21/2017 19:40'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MatasCadaval 11/21/2017 19:38'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MatasCadaval 11/21/2017 19:42'!assertRecordNotEmpty	record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/23/2017 09:19'!signalInvalidSupplierRecord	self error: self class invalidSupplierRecordErrorDescription! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/23/2017 00:20'!signalNewCustomerAsExistingCustomer	self error: self class newCustomerAsExistingCustomerErrorDescription  ! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/21/2017 21:11'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/23/2017 08:46'!signalAddressWithoutSupplierError	self error: self class addressWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/23/2017 01:53'!signalExistingCustomerAsNewCustomer	self error: self class existingCustomerAsNewCustomerErrorDescription! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/23/2017 14:40'!signalCustomerWithoutSupplierError	self error: self class customerWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'error signal' stamp: 'MatasCadaval 11/23/2017 09:18'!signalInvalidCustomerRecord	self error: self class invalidCustomerRecordErrorDescription ! !!SupplierImporter methodsFor: 'importing' stamp: 'MatasCadaval 11/21/2017 19:37'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/23/2017 02:53'!assertValidAddressRecordSize	record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/23/2017 15:13'!importAddress	| newAddress |	self assertValidAddressRecordSize.	self assertThereIsSupplierForAddress .	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	newSupplier addAddress: newAddress! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/23/2017 08:52'!assertThereIsSupplierForAddress	newSupplier isNil ifTrue: [ self signalAddressWithoutSupplierError ].! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/21/2017 21:27'!isAddressRecord	^ record first = 'A'! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MatasCadaval 11/23/2017 02:54'!signalInvalidAddressRecord	self error: self class invalidAddressRecordErrorDescription ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'MatasCadaval 11/21/2017 19:32'!from: aReadStream on: anErpSystem 	^self new initializeOn: aReadStream on: anErpSystem ! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/23/2017 00:12'!newCustomerAsExistingCustomerErrorDescription	^'New customer given as existing customer'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/23/2017 09:24'!invalidCustomerRecordErrorDescription	^'Invalid customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/23/2017 01:53'!existingCustomerAsNewCustomerErrorDescription	^'Existing customer given as new customer'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/23/2017 08:47'!addressWithoutSupplierErrorDescription	^'There is no Supplier for the imported address'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/21/2017 19:55'!invalidSupplierRecordErrorDescription	^'Invalid supplier record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/23/2017 14:41'!customerWithoutSupplierErrorDescription	^'There is no Supplier for the imported customer'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/21/2017 21:12'!invalidRecordTypeErrorDescription	^'Invalid record type'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MatasCadaval 11/23/2017 02:46'!invalidAddressRecordErrorDescription	^'Invalid address record'! !Object subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierSystem methodsFor: 'as yet unclassified' stamp: 'MatasCadaval 11/23/2017 18:28'!allSuppliersSize
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:28'!commit
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:28'!start
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:28'!beginTransaction
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:28'!stop
	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:28'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock
	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:28'!isSuppliersEmpty
	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:28'!addSupplier: aSupplier
	self subclassResponsibility! !!SupplierSystem methodsFor: 'initialization' stamp: 'MatasCadaval 11/23/2017 18:28'!initialize
	self subclassResponsibility! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 00:38'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock 	| suppliers |	suppliers := session		select: [ :aSupplier | 			aSupplier identificationType = anIdentifycationType				and: [ aSupplier identificationNumber = anIdentificationNumber ] ]		ofType: Supplier.	^ suppliers size = 1		ifTrue: [ suppliers anyOne ]		ifFalse: noneBlock! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/21/2017 20:03'!isSuppliersEmpty	^ (session selectAllOfType: Supplier) isEmpty! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 14:57'!allSuppliersSize	^ (session selectAllOfType: Supplier) size! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/21/2017 23:15'!addSupplier: aSupplier 	session persist: aSupplier ! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'MatasCadaval 11/22/2017 23:44'!initialize	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping)		! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/21/2017 20:24'!addressMapping		^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/22/2017 22:41'!commit	session commit! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/21/2017 20:56'!start	session open! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/21/2017 20:26'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/21/2017 20:55'!beginTransaction	session beginTransaction! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/22/2017 23:18'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier 		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/22/2017 22:41'!stop	session close! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/20/2017 20:26'!addCustomer: aCustomer	customers add: aCustomer ! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/20/2017 20:33'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneBlock	^customers 		detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ]		ifFound: [ :aCustomer | aCustomer ]		ifNone: noneBlock  ! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/20/2017 20:40'!allCustomersSize	^ customers size ! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'MatasCadaval 11/20/2017 20:39'!isCustomersEmpty	^ customers isEmpty ! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/20/2017 20:36'!commit! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/20/2017 20:20'!start	customers := OrderedCollection new ! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/20/2017 20:21'!beginTransaction! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'MatasCadaval 11/21/2017 00:34'!stop! !ErpSystem subclass: #TransientErpSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientErpSystem methodsFor: 'initialization' stamp: 'MatasCadaval 11/23/2017 18:30'!initialize	customerSystem := TransientCustomerSystem new .	supplierSystem := TransientSupplierSystem new .! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientSupplierSystem methodsFor: 'initialization' stamp: 'MatasCadaval 11/23/2017 18:33'!initialize	suppliers := OrderedCollection new! !!TransientSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:41'!commit! !!TransientSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:41'!stop! !!TransientSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:40'!start! !!TransientSupplierSystem methodsFor: 'setup - teardown' stamp: 'MatasCadaval 11/23/2017 18:40'!beginTransaction! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:45'!supplierIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneBlock 	^suppliers  		detect: [ :aSupplier | aSupplier isIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ]		ifFound: [ :aSupplier | aSupplier ]		ifNone: noneBlock  ! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:41'!isSuppliersEmpty	^ suppliers isEmpty ! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:46'!allSuppliersSize	^ suppliers size ! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MatasCadaval 11/23/2017 18:43'!addSupplier: aSupplier	suppliers add: aSupplier ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60519] on 23 November 2017 at 6:57:54.737525 pm'!!String methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60519] on 23 November 2017 at 6:57:54.738015 pm'!!Object methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !